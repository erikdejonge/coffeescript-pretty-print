// Generated by CoffeeScript 1.7.0
"use strict";
angular.module("cryptoboxApp.services", ["ngResource", "ng"]).factory("tree", [
  "$http", "$q", "memory", "urls", "utils", "$upload", function($http, $q, memory, urls, utils, $upload) {
    var m_getting_version, m_loading, m_tree_loaded, m_tree_nodes, _get, _get_children_tree, _get_icons, _get_node, _invalidate, _parse_tree;
    m_loading = false;
    m_tree_loaded = false;
    m_getting_version = false;
    m_tree_nodes = null;
    _parse_tree = function(tree_nodes) {
      var add_parent, all_knodes, build_tree, find_knode, items, knodes, make_node, path_len_sort, root_node, root_nodes;
      add_parent = function(k) {
        tree_nodes[k].slugpath = k;
        tree_nodes[k].slugpath_parent = utils.path_dirname(k);
        if (strcmp(tree_nodes[k].slugpath_parent, "/") && strcmp(tree_nodes[k].slugpath, "/")) {
          return tree_nodes[k].slugpath_parent = "";
        }
      };
      _.each(_.keys(tree_nodes), add_parent);
      root_nodes = _.filter(tree_nodes, function(n) {
        return strcmp(n.slugpath, "/");
      });
      if (_.size(root_nodes) > 1) {
        warning("services.cf:21", "multiple rootnodes");
      }
      make_node = function(node) {
        var obj;
        obj = {};
        obj["parent"] = node.slugpath_parent;
        if (obj["parent"] == null) {
          obj["parent"] = "";
        }
        obj["text"] = node.m_name_p64s;
        if (obj["text"] === "/") {
          obj["text"] = "Home";
        }
        obj["type"] = node.m_nodetype;
        obj["slugpath"] = node.m_slugpath_p64s;
        obj["content_hash"] = node.content_hash;
        if (memory.get("g_c_device_pixel_ratio") > 1) {
          obj["imageUrl"] = "/st/img/tree-" + node.m_nodetype + "@2x.png";
        } else {
          obj["imageUrl"] = "/st/img/tree-" + node.m_nodetype + ".png";
        }
        return obj;
      };
      all_knodes = _.map(tree_nodes, make_node);
      root_node = make_node(root_nodes[0]);
      items = [];
      find_knode = function(slugpath, searchnodes) {
        var found_node, kn, _i, _j, _len, _len1;
        found_node = null;
        for (_i = 0, _len = searchnodes.length; _i < _len; _i++) {
          kn = searchnodes[_i];
          if (strcmp(kn.slugpath, slugpath)) {
            found_node = kn;
          }
        }
        if (!found_node) {
          for (_j = 0, _len1 = searchnodes.length; _j < _len1; _j++) {
            kn = searchnodes[_j];
            if (kn["items"] != null) {
              found_node = find_knode(slugpath, kn["items"]);
              if (found_node) {
                break;
              }
            }
          }
        }
        return found_node;
      };
      knodes = [root_node];
      path_len_sort = function(item) {
        var plen;
        plen = (1000 * _.size(item.slugpath.split("/"))) + _.size(item.slugpath);
        return plen;
      };
      all_knodes = _.sortBy(all_knodes, path_len_sort);
      build_tree = function(nodes) {
        var node, parent_knode, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = all_knodes.length; _i < _len; _i++) {
          node = all_knodes[_i];
          if (node.type === "folder") {
            parent_knode = find_knode(node.parent, knodes);
            if (parent_knode != null) {
              if (utils.exist(parent_knode["items"])) {
                _results.push(parent_knode["items"].push(node));
              } else {
                parent_knode["items"] = [];
                _results.push(parent_knode["items"].push(node));
              }
            } else {
              _results.push(parent_knode = find_knode(node.parent, knodes));
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      build_tree(knodes);
      memory.set("g_kendo_tree_folders", knodes);
      return tree_nodes;
    };
    _get_node = function(node_id_or_slugpath, tree) {
      var find_node, node;
      if (!utils.exist(node_id_or_slugpath)) {
        node_id_or_slugpath = "";
      }
      find_node = function(item) {
        if (item.m_short_id === node_id_or_slugpath) {
          return true;
        } else {
          return strcmp(item.m_slugpath_p64s, node_id_or_slugpath);
        }
      };
      node = _.filter(tree, find_node);
      if (utils.exist(node)) {
        if (node[0]) {
          return node[0];
        }
      }
      return null;
    };
    _get_children_tree = function(parent, tree) {
      var children, doclist, format_file_size, get_children;
      if (parent === "") {
        parent = tree["/"];
      }
      parent = parent.slugpath;
      get_children = function(item) {
        return strcmp(item.slugpath_parent, parent) && !strcmp(item.slugpath, parent);
      };
      children = _.filter(tree, get_children);
      format_file_size = function(item) {
        item.m_size_human = g_format_file_size(Math.round(parseFloat(item.m_size_p64s)));
        return item;
      };
      doclist = _.filter(children, format_file_size);
      return doclist;
    };
    _get_icons = function(item) {
      var mini_mime;
      mini_mime = utils.get_mini_mime(item.m_mime, item.m_name_p64s);
      item.mini_mime = mini_mime;
      if (!utils.exist(item.m_mime)) {
        item.m_mime = mini_mime;
      }
      item.icon = utils.match_mime_small_icon(mini_mime);
      item.icon_2x = item.icon.replace(".png", "@2x.png");
      item.icon_4x = item.icon.replace(".png", "@4x.png");
      item.icon_large = utils.match_mime_large_icon(mini_mime);
      return item;
    };
    _get = function() {
      var tree_promise, treenodes, url2;
      tree_promise = $q.defer();
      treenodes = memory.get("g_tree");
      if (utils.exist(treenodes)) {
        tree_promise.resolve(treenodes);
      } else {
        if (!memory.has("g_mimetypes_lut")) {
          utils.http_get_cached("/st/data/mimetypes.json").then(function(content) {
            return memory.set("g_mimetypes_lut", content);
          }, function(e) {
            return warning("services.cf:142", "could not get the mime types", e);
          });
        }
        url2 = urls.command("services.cf:144", "treedict");
        m_loading = true;
        $http.post(url2).then(function(databack) {
          var tree_nodes;
          m_loading = false;
          memory.critical_set("g_tree_seq", databack.data[0]);
          tree_nodes = _parse_tree(databack.data[1]);
          m_tree_loaded = true;
          tree_promise.resolve(tree_nodes);
          return memory.critical_set("g_tree", tree_nodes);
        }, function(error) {
          m_loading = false;
          m_tree_loaded = false;
          tree_promise.reject();
          return urls.http_error(error);
        });
      }
      return tree_promise.promise;
    };
    _invalidate = function() {
      memory.set("g_first_tree_render", true);
      m_tree_loaded = false;
      m_loading = false;
      memory.del("g_tree");
      memory.del_prefix("g_doc_list");
      memory.del_prefix("g_filter_tree");
      return memory.del_prefix("g_http_get_cached");
    };
    return {
      get_children_tree: function(parent, tree) {
        return _get_children_tree(parent, tree);
      },
      get_info_document: function(object_id) {
        var data, p, url, versions;
        p = $q.defer();
        versions = null;
        if (m_getting_version) {
          p.resolve([]);
        } else {
          versions = memory.get("g_info_doc_" + object_id);
        }
        if (utils.exist(versions)) {
          p.resolve(versions);
        } else {
          m_getting_version = true;
          data = {};
          data["object_id"] = object_id;
          data = object_b64_safe(data);
          url = urls.postcommand("services.cf:192", "docinfo", "get");
          $http.post(url, data).then(function(databack) {
            databack = b64_object_safe(databack);
            memory.set("g_info_doc_" + object_id, databack.data[1]);
            p.resolve(databack.data[1]);
            return m_getting_version = false;
          }, function(errordata) {
            m_getting_version = false;
            return p.reject(urls.http_error(errordata.data));
          });
        }
        return p.promise;
      },
      get_node: function(node_id_or_slugpath, tree) {
        return _get_node(node_id_or_slugpath, tree);
      },
      get_node_by_id: function(node_id) {
        var g_tree;
        g_tree = memory.get("g_tree");
        return _get_node(node_id, g_tree);
      },
      get_node_slugpath: function(slugpath, tree) {
        var find_node, node;
        slugpath = utils.slugify(slugpath);
        find_node = function(item) {
          if (utils.exist(item.doc)) {
            return utils.strcmp(item.doc.m_slugpath_p64s, slugpath);
          }
          return false;
        };
        node = _.filter(tree, find_node);
        if (utils.exist(node)) {
          if (node[0]) {
            if (utils.exist(node[0].doc)) {
              return node[0].doc;
            }
          }
        }
        return null;
      },
      calculate_size: function(tree_nodes) {
        var add_folder_sizes, add_sizes;
        add_folder_sizes = function(folder) {
          var cnt, np, parent;
          if (folder.m_nodetype === "folder") {
            parent = utils.filter_key_value(tree_nodes, "_id", folder.parent);
            if (_.size(parent) > 0) {
              parent = parent[0];
            }
            if (utils.exist(parent)) {
              parent.m_size_p64s += folder.m_size_p64s;
              np = utils.filter_key_value(tree_nodes, "_id", parent.parent);
              if (_.size(np) > 0) {
                np = np[0];
              } else {
                np = null;
              }
              cnt = 0;
              while (utils.exist(np)) {
                if (utils.exist(np.doc)) {
                  np.doc.m_size_p64s += folder.doc.m_size_p64s;
                  print("services.cf:249", np.doc.m_size_p64s);
                }
                if (exitst(np.parent)) {
                  np = utils.filter_key_value(tree_nodes, "_id", np.parent);
                  if (_.size(np) > 0) {
                    np = np[0];
                  } else {
                    np = null;
                  }
                } else {
                  np = null;
                }
                cnt += 1;
                if (cnt > 1000) {
                  np = null;
                }
              }
            }
            return _.each(folder.children, add_folder_sizes);
          }
        };
        add_sizes = function(tree_nodes) {
          var folder_size;
          folder_size = function(node) {
            var get_size, total;
            if (node.m_nodetype === "folder") {
              total = 0;
              get_size = function(node) {
                return total += node.m_size_p64s;
              };
              _.each(node.children, get_size);
              return node.m_size_p64s = total;
            }
          };
          _.each(tree_nodes, folder_size);
          _.each(tree_nodes, add_folder_sizes);
          return tree_nodes;
        };
        return add_sizes(tree_nodes);
      },
      get_extension: function(mimetype) {
        var check_mimetype, ext, exts, mimetypes;
        mimetypes = memory.get("g_mimetypes_lut");
        if (!utils.exist(mimetypes)) {
          warning("services.cf:287", "get extension mime types not loaded");
          return "";
        }
        exts = mimetypes[mimetype];
        ext = "";
        check_mimetype = function(i) {
          if (ext === "") {
            return ext = i;
          }
        };
        _.each(exts, check_mimetype);
        return ext;
      },
      get_icons: function(item) {
        return _get_icons(item);
      },
      filter_tree: function(parent, tree, sort_string, cvar_sort_folders_top, cvar_hide_file_extensions) {
        var backupname_get_icons, date_sort, doclist, filtered_tree_from_memory, find_root, folders_first, format_file_size, get_doc, get_types, hash_for_call, name_sort, root_short_id, size_sort, sortitems, treedocs;
        if (utils.exist(parent)) {
          hash_for_call = utils.sha3(parent.m_slugpath_p64s, tree, sort_string, cvar_sort_folders_top, cvar_hide_file_extensions);
          filtered_tree_from_memory = memory.get("g_filter_tree_" + hash_for_call);
        }
        if (utils.exist(filtered_tree_from_memory)) {
          return filtered_tree_from_memory;
        } else {
          if (!utils.exist(parent)) {
            parent = "";
          }
          if (utils.exist(parent)) {
            treedocs = _get_children_tree(parent, tree);
          } else {
            get_doc = function(item) {
              return item.doc;
            };
            doclist = _.map(tree, get_doc);
            format_file_size = function(item) {
              item.m_size_human = g_format_file_size(Math.round(parseFloat(item.m_size_p64s)));
              return item;
            };
            treedocs = _.filter(doclist, format_file_size);
          }
          doclist = [];
          folders_first = function(item) {
            return item.m_nodetype;
          };
          name_sort = function(item) {
            return item.m_name_p64s.toLowerCase();
          };
          size_sort = function(item) {
            return item.m_size_p64s;
          };
          date_sort = function(item) {
            return item.m_date;
          };
          sortitems = function(method, reverse) {
            var file, folders, groups;
            groups = null;
            if (utils.exist_truth(cvar_sort_folders_top)) {
              groups = _.groupBy(treedocs, folders_first);
            }
            if (utils.exist(groups)) {
              if (utils.exist(method)) {
                folders = _.sortBy(groups.folder, method);
                file = _.sortBy(groups.file, method);
              } else {
                folders = groups.folder;
                file = groups.file;
              }
              if (reverse) {
                folders = folders.reverse();
              }
              if (reverse) {
                file = file.reverse();
              }
              if (utils.exist(folders)) {
                if (utils.exist(file)) {
                  doclist = folders.concat(file);
                } else {
                  doclist = folders;
                }
              } else {
                doclist = file;
              }
            } else {
              if (utils.exist(method)) {
                doclist = _.sortBy(treedocs, method);
              } else {
                doclist = treedocs;
              }
              if (reverse) {
                doclist = doclist.reverse();
              }
            }
            return doclist;
          };
          if (utils.exist(parent)) {
            switch (sort_string) {
              case "down_name":
                doclist = sortitems(name_sort, false);
                break;
              case "up_name":
                doclist = sortitems(name_sort, true);
                break;
              case "down_size":
                doclist = sortitems(size_sort, false);
                break;
              case "up_size":
                doclist = sortitems(size_sort, true);
                break;
              case "down_date":
                doclist = sortitems(date_sort, false);
                break;
              case "up_date":
                doclist = sortitems(date_sort, true);
                break;
              default:
                warning("services.cf:388", "sortstring unknown - " + sortstring);
            }
          } else {
            doclist = sortitems(null, false);
          }
          backupname_get_icons = function(item) {
            if (utils.exist_truth(cvar_hide_file_extensions)) {
              if (utils.exist(item.backupname)) {
                item.m_name_p64s = item.backupname;
              } else {
                item.backupname = item.m_name_p64s;
              }
            }
            return _get_icons(item);
          };
          doclist = _.map(doclist, backupname_get_icons);
          root_short_id = null;
          find_root = function(node) {
            return !utils.exist(node.slugpath_parent);
          };
          if (_.size(tree) > 0) {
            root_short_id = _.find(tree, find_root);
            if (utils.exist(root_short_id)) {
              root_short_id = root_short_id.m_short_id;
            }
          }
          get_types = function(item) {
            var break_point, charcnt, find_read_right_node, i, new_name, read_right, _i, _len, _ref;
            if (utils.strcmp(item.slugpath_parent, root_short_id)) {
              if (memory.has("g_read_rights")) {
                find_read_right_node = function(rr) {
                  return rr.m_node_short_id === item.m_short_id;
                };
                read_right = _.filter(memory.get("g_read_rights"), find_read_right_node);
                if (_.size(read_right) > 0) {
                  item.icon = item.icon.replace("icon-folder", "icon-folder-root");
                  item.icon_2x = item.icon_2x.replace("icon-folder", "icon-folder-root");
                  item.icon_4x = item.icon_4x.replace("icon-folder", "icon-folder-root");
                  item.icon_large = item.icon_large.replace("icon-folder", "icon-folder-root");
                }
              }
            }
            item.m_human_type = "folder";
            if (item.m_nodetype !== "folder") {
              item.m_human_type = utils.get_mini_mime(item.m_mime, item.m_name_p64s);
            }
            if (item.m_name_p64s.length > 30) {
              new_name = "";
              charcnt = 0;
              break_point = 80;
              if (memory.get("g_device_type") === "phone") {
                break_point = 30;
              }
              _ref = item.m_name_p64s;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                i = _ref[_i];
                new_name += i;
                charcnt += 1;
                if (charcnt > break_point) {
                  charcnt = 0;
                  new_name += " ";
                }
              }
              item.m_name_p64s = new_name;
            }
            if (!utils.exist(item.m_mime)) {
              item.m_mime = item.mini_mime;
            }
            if (!utils.exist(item.m_mime)) {
              item.m_mime = utils.file_extension(item.m_name_p64s);
            }
            if (utils.exist_truth(cvar_hide_file_extensions)) {
              item.m_name_p64s = utils.strip_file_extension(item.m_name_p64s);
            }
            return item;
          };
          doclist = _.map(doclist, get_types);
          memory.set("g_filter_tree_" + hash_for_call, doclist);
        }
        return doclist;
      },
      is_folder: function(node) {
        if (utils.exist(node)) {
          return node.m_nodetype === "folder";
        } else {
          return false;
        }
      },
      make_routing: function(node, tree) {
        var addlast, make_r_node, node_size, nodes, truncate_title;
        nodes = [];
        make_r_node = function(sourcenode) {
          var r_node;
          r_node = {
            route: urls.make_route("/docs/" + sourcenode.m_short_id),
            m_name_p64s: sourcenode.m_name_p64s,
            m_slug_p64s: sourcenode.m_slug_p64s,
            m_name_p64s_escaped: utils.asciistring_lowercase(sourcenode.m_name_p64s),
            m_nodetype: sourcenode.m_nodetype,
            m_short_id: sourcenode.m_short_id,
            m_node_type: sourcenode.m_node_type,
            is_folder: sourcenode.m_nodetype === "folder"
          };
          r_node.m_name_p64s_escaped = utils.asciistring_lowercase(sourcenode.m_name_p64s);
          return r_node;
        };
        if (node) {
          nodes.push(make_r_node(node));
          while (!strcmp(node.slugpath, "/")) {
            node = _get_node(node.slugpath_parent, tree);
            nodes.push(make_r_node(node));
          }
        }
        addlast = function(node) {
          node.last = false;
          node.secondlast = false;
          node.thirdlast = false;
          node.fourthlast = false;
          node.fifthlast = false;
          node.sixthlast = false;
          node.seventhlast = false;
          return node;
        };
        nodes = _.map(nodes, addlast);
        nodes = nodes.reverse();
        node_size = _.size(nodes);
        if (node_size > 0) {
          nodes[node_size - 1].last = true;
        }
        if (node_size > 1) {
          nodes[node_size - 2].secondlast = true;
        }
        if (node_size > 2) {
          nodes[node_size - 3].thirdlast = true;
        }
        if (node_size > 3) {
          nodes[node_size - 4].fourthlast = true;
        }
        if (node_size > 4) {
          nodes[node_size - 5].fifthlast = true;
        }
        if (node_size > 5) {
          nodes[node_size - 6].sixthlast = true;
        }
        if (node_size > 6) {
          nodes[node_size - 7].seventhlast = true;
        }
        if (utils.is_phone() || utils.is_tablet()) {
          truncate_title = function(item) {
            if (_.size(item.m_name_p64s) > 20) {
              item.m_name_p64s = item.m_name_p64s.slice(0, 20) + "...";
              return item.m_name_p64s_escaped = item.m_name_p64s_escaped.slice(0, 20) + "...";
            }
          };
          _.each(nodes, truncate_title);
        }
        if (node_size > 0) {
          if (strcmp(nodes[0].m_name_p64s_escaped, "/")) {
            nodes[0].m_name_p64s_escaped = "home";
          }
        }
        return nodes;
      },
      inmem: function() {
        var tree;
        tree = memory.get("g_tree");
        return utils.exist(tree);
      },
      add_folder: function(parent, folder_name) {
        var data, p, url;
        p = $q.defer();
        data = {};
        data["parent"] = parent;
        data["foldername"] = folder_name;
        data = object_b64_safe(data);
        url = urls.command("services.cf:550", "docs/makefolder");
        $http.post(url, data).then(function(success) {
          return p.resolve(success);
        }, function(e) {
          g_http_error(e.data);
          return p.reject("server error");
        });
        return p.promise;
      },
      read_right: function(node_short_id, user_id, operation) {
        var data, p, url;
        p = $q.defer();
        data = {};
        data["node_short_id"] = node_short_id;
        data["user_object_id"] = user_id;
        data["operation"] = operation;
        data = object_b64_safe(data);
        url = urls.command("services.cf:568", "assignreadright");
        $http.post(url, data).then(function(success) {
          p.resolve(success);
          _invalidate();
          return _get();
        }, function(e) {
          return p.reject(urls.http_error(e.data));
        });
        return p.promise;
      },
      delete_tree_items: function(item_list) {
        var data, p, url;
        p = $q.defer();
        url = urls.command("services.cf:583", "docs/delete");
        data = {};
        data["json_data"] = true;
        data["tree_item_list"] = item_list;
        $http.post(url, data).then(function() {
          memory.del("g_tree");
          return p.resolve();
        }, function(e) {
          return p.reject(urls.http_error(e.data));
        });
        return p.promise;
      },
      get_tree_loaded: function() {
        return m_tree_loaded;
      },
      mem_get: function() {
        return memory.get("g_tree");
      },
      invalidate: function() {
        return _invalidate();
      },
      get: function() {
        return _get();
      },
      get_parent: function() {
        var tree_promise, url;
        tree_promise = $q.defer();
        url = urls.command("services.cf:611", "tree");
        $http.post(url).then(function(databack) {
          var tree_nodes;
          tree_nodes = databack.data[1];
          memory.critical_set("g_tree_seq", databack.data[0]);
          memory.critical_set("g_tree", tree_nodes);
          m_tree_loaded = true;
          return tree_promise.resolve(tree_nodes);
        }, function(data) {
          tree_promise.reject();
          return urls.http_error(data);
        });
        return tree_promise.promise;
      },
      dosearch: function(terms) {
        var check_name, nodes, results;
        nodes = memory.get("g_tree");
        if (!utils.exist(nodes)) {
          warning("services.cf:630", "cannot search not tree loaded");
          return [];
        }
        results = [];
        check_name = function(node) {
          var check_nodes, selected;
          selected = true;
          check_nodes = function(term) {
            if (node.doc.m_name_p64s.toLowerCase().indexOf(term.toLowerCase()) < 0) {
              return selected = false;
            }
          };
          _.each(terms.split(" "), check_nodes);
          if (selected) {
            if (node.doc.m_nodetype === 'file') {
              return results.push(node);
            }
          }
        };
        _.each(nodes, check_name);
        return results;
      },
      all_nodes_recursive: function(tree_nodes, short_id_parent) {
        var get_all_children_recursive, nodes;
        get_all_children_recursive = function(allnodes, parent) {
          var children, get_all_children, parents;
          children = [];
          parents = [];
          get_all_children = function(item) {
            if (item.parent === parent) {
              children.push(item);
              if (item.doc.m_nodetype === 'folder') {
                return parents.push(item.doc.m_short_id);
              }
            }
          };
          _.each(allnodes, get_all_children);
          while (_.size(parents) > 0) {
            parent = parents.pop();
            _.each(allnodes, get_all_children);
          }
          return children;
        };
        nodes = get_all_children_recursive(tree_nodes, short_id_parent);
        return nodes;
      },
      change_name: function(node_short_id, nodename) {
        var data, p, url;
        p = $q.defer();
        data = {};
        data["node_short_id"] = node_short_id;
        data["nodename"] = nodename.trim();
        data = object_b64_safe(data);
        url = urls.command("services.cf:674", "docs/changename");
        $http.post(url, data).then(function(success) {
          return p.resolve(success);
        }, function(e) {
          return p.reject(urls.http_error(e.data));
        });
        return p.promise;
      },
      move: function(nodes, parent) {
        var data, p, url;
        p = $q.defer();
        data = {};
        data["nodes"] = nodes;
        data["parent"] = parent;
        data = object_b64_safe(data);
        url = urls.command("services.cf:691", "docs/move");
        $http.post(url, data).then(vhRXiUm9KY2g39rjoz, function(success) {
          _invalidate();
          return _get().then(function() {
            return p.resolve(success);
          }, function(err) {
            return p.reject(err);
          });
        }, function(e) {
          return p.reject(urls.http_error(e.data));
        });
        return p.promise;
      },
      load_tree: function(m_tree_nodes_tmp) {
        var path, _i, _len, _ref;
        _ref = _.keys(m_tree_nodes_tmp);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          if (utils.slugify_path(m_tree_nodes_tmp[path].m_path_p64s) !== path) {
            throw "parse json: difference in slug algorithm";
          }
          m_tree_nodes[path] = m_tree_nodes_tmp[path];
        }
        return m_tree_nodes;
      },
      get_root: function() {
        if (utils.exist(m_tree_nodes)) {
          return m_tree_nodes["/"];
        }
      },
      parse_json: function(jsondata) {
        var m_tree_nodes_tmp;
        m_tree_nodes = {};
        m_tree_nodes_tmp = utils.json2obj(jsondata);
        return this.load_tree(m_tree_nodes_tmp);
      },
      ls: function(path, recursive, include_parent) {
        var npath, order_sort, path_len_sort, result, _i, _len, _ref;
        if (!utils.exist(m_tree_nodes)) {
          print("services.cf:728", "m_tree_nodes not loaded (tree.parse_json)");
          return [];
        }
        if (!utils.exist(recursive)) {
          recursive = false;
        }
        result = [];
        path = utils.slugify_path(path);
        _ref = _.keys(m_tree_nodes);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          npath = _ref[_i];
          if (strcmp(npath, path)) {
            if (strcmp(m_tree_nodes[npath].m_nodetype, "file")) {
              return [m_tree_nodes[npath]];
            } else {
              if (utils.exist(include_parent)) {
                if (include_parent) {
                  result.push(m_tree_nodes[npath]);
                }
              }
            }
          }
          if (recursive) {
            if (string_contains(utils.path_dirname(npath), path)) {
              if (strcmp(npath, path)) {
                if (include_parent) {
                  result.push(m_tree_nodes[npath]);
                }
              } else {
                result.push(m_tree_nodes[npath]);
              }
            }
          } else {
            if (strcmp(utils.path_dirname(npath), path)) {
              if (strcmp(npath, "/")) {
                if (include_parent) {
                  result.push(m_tree_nodes[npath]);
                }
              } else {
                result.push(m_tree_nodes[npath]);
              }
            }
          }
        }
        result = _.uniq(result);
        order_sort = function(item) {
          return item.m_order;
        };
        result = _.sortBy(result, order_sort);
        path_len_sort = function(item) {
          var plen;
          plen = (1000 * _.size(item.m_slugpath_p64s.split("/"))) + _.size(item.m_slugpath_p64s);
          return plen;
        };
        result = _.sortBy(result, path_len_sort);
        return result;
      },
      parse_tree: function(nodes) {
        return _parse_tree(nodes);
      }
    };
  }
]).factory("serverclock", [
  "$http", "$q", "urls", "memory", "utils", "$rootScope", "tree", "authorization", function($http, $q, urls, memory, utils, $rootScope, tree, authorization) {
    var last_check, _get_time, _get_time_interval;
    last_check = new Date().getTime();
    _get_time = function() {
      var local_time, t;
      local_time = new Date().getTime();
      t = memory.get("g_corrected_servertime");
      if (!utils.exist(t)) {
        if (!memory.has("g_last_received_servertime")) {
          memory.set("g_last_received_servertime", local_time);
          last_check = new Date().getTime();
        }
        if (!memory.has("g_corrected_servertime")) {
          memory.set("g_corrected_servertime", local_time);
          last_check = new Date().getTime();
        }
      }
      return t;
    };
    _get_time_interval = function() {
      var local_time, mfloat, new_corrected_servertime, time_since_check, url;
      local_time = new Date().getTime();
      if (!memory.has("g_last_received_servertime")) {
        memory.set("g_last_received_servertime", local_time);
        last_check = new Date().getTime();
      }
      if (!memory.has("g_corrected_servertime")) {
        memory.set("g_corrected_servertime", local_time);
        last_check = new Date().getTime();
      }
      mfloat = function(s) {
        return parseFloat(s);
      };
      time_since_check = mfloat(mfloat(local_time) - mfloat(last_check));
      if (memory.has("g_last_received_servertime")) {
        new_corrected_servertime = mfloat(memory.get("g_last_received_servertime")) + time_since_check;
        memory.set("g_corrected_servertime", new_corrected_servertime);
      }
      if (time_since_check > 30000) {
        url = urls.command("services.cf:816", "clock");
        return $http.post(url).then(function(databack) {
          var servertime;
          last_check = new Date().getTime();
          servertime = parseFloat(databack.data[0]);
          memory.set("g_last_received_servertime", servertime);
          return memory.set("g_corrected_servertime", parseFloat(databack.data[0]));
        }, function(errordata) {
          print("services.cf:838", "get_time_interval", errordata);
          if (errordata.status === 403) {
            return authorization.logout();
          }
        });
      }
    };
    return {
      init: function() {
        var service_get_time_interval;
        print("services.cf:844", "init serverclock");
        service_get_time_interval = utils.set_interval("services.cf:845", _get_time_interval, 1000, "_get_time_interval");
        return memory.set("g_service_get_time_interval", service_get_time_interval);
      },
      get_time: function() {
        return _get_time();
      }
    };
  }
]).factory("cryptobox", [
  "$http", "$q", "$location", "memory", "clientcookies", "utils", "urls", "cvar", function($http, $q, $location, memory, clientcookies, utils, urls, cvar) {
    var f_fetch, last_result, lastfetch, loading;
    loading = false;
    lastfetch = null;
    last_result = null;
    f_fetch = function() {
      var cryptobox_promise, url;
      cryptobox_promise = $q.defer();
      url = urls.command("services.cf:862", "config");
      loading = true;
      $http.post(url).then(function(result) {
        if (result.data[0]) {
          last_result = result.data[1];
          cryptobox_promise.resolve(result.data[1]);
          lastfetch = get_local_time();
        } else {
          cryptobox_promise.reject();
        }
        return loading = false;
      }, function(data) {
        urls.http_error(data);
        cryptobox_promise.reject();
        return loading = false;
      });
      return cryptobox_promise.promise;
    };
    return {
      init: function() {
        var init_cvar, p;
        p = $q.defer();
        memory.critical_set("g_persist_browser", BrowserDetect.browser);
        memory.critical_set("g_persist_browser_version", BrowserDetect.version);
        init_cvar = function(key, value) {
          return cvar.get(key).then(function(resolve_result) {
            if (!utils.exist(resolve_result)) {
              print("services.cf:890", "init-cvar", key);
              if (utils.exist(value)) {
                return cvar.set(key, value);
              }
            }
          }, function(reject_result) {
            return warning("services.cf:895", "init cvar rejected", reject_result);
          });
        };
        init_cvar("cvar_docs_sort_string", "");
        init_cvar("cvar_show_drop_area", true);
        init_cvar("cvar_docs_sort_string", "down_name");
        init_cvar("cvar_sort_folders_top", true);
        init_cvar("cvar_hide_file_extensions", false);
        init_cvar("cvar_disable_caching", false);
        init_cvar("cvar_use_menu_routing", false);
        init_cvar("cvar_show_debug_info", false);
        init_cvar("cvar_user_should_change_password", false);
        cvar.commit_retrieve_all().then(function(cvars) {
          print("services.cf:910", _.size(cvars) + " cvars");
          return p.resolve();
        }, function(error) {
          print("services.cf:914", "error", "init cryptobox", error);
          return p.reject();
        });
        return p.promise;
      },
      get_app_var: function(g_var) {
        var get_var, p;
        p = $q.defer();
        get_var = function() {
          var app_var;
          app_var = memory.get(g_var);
          if (utils.exist(app_var)) {
            return p.resolve(app_var);
          } else {
            if (g_var !== "g_doc_count" && g_var !== "g_diskspace") {
              p.reject("unknown appvar " + g_var);
            }
            return f_fetch().then(function(cryptobox) {
              if (utils.exist(cryptobox.m_info.doc_count)) {
                memory.critical_set("g_doc_count", cryptobox.m_info.doc_count);
                memory.critical_set("g_diskspace", cryptobox.diskspace);
                app_var = memory.get(g_var);
                return p.resolve(app_var);
              }
            }, function(err) {
              return pp.reject("could not fetch cryptobox appvar " + g_var + "(" + err + ")");
            });
          }
        };
        get_var();
        return p.promise;
      },
      get: function() {
        return f_fetch();
      },
      slug: function() {
        return utils.get_cryptobox_slug();
      }
    };
  }
]).factory("authorization", [
  "$http", "$q", "$location", "memory", "utils", "clientcookies", "urls", function($http, $q, $location, memory, utils, clientcookies, urls) {
    var f_server_logout, _logincheck;
    _logincheck = function(username, password, trust_computer, private_key) {
      var base64_data, data, login_promise, url;
      login_promise = $q.defer();
      if (!utils.exist(username)) {
        warning("services.cf:960", "username doesn not exist");
      }
      if (!utils.exist(password)) {
        warning("services.cf:963", "password does not exist");
      }
      url = urls.command("services.cf:964", "authorize");
      data = {};
      data.username = username;
      data.password = password;
      data.trust_computer = trust_computer;
      data.private_key = private_key;
      base64_data = object_b64_safe(data);
      $http.post(url, base64_data).then(function(success_result) {
        if (utils.exist_truth(success_result.data[0])) {
          return login_promise.resolve(success_result.data[1]);
        } else {
          return login_promise.reject("we konden u niet inloggen");
        }
      }, function(error_data) {
        urls.http_error(error_data);
        return login_promise.reject();
      });
      return login_promise.promise;
    };
    f_server_logout = function() {
      var p, url;
      p = $q.defer();
      url = urls.command("services.cf:988", "logoutserver");
      $http.post(url).then(function(success_result) {
        print("services.cf:991", "server", "loggedout");
        memory.reset();
        urls.change_route($location, "/logout");
        return p.resolve(success_result);
      }, function(error) {
        print("services.cf:997", "could not logout");
        memory.reset();
        urls.change_route($location, "/logout");
        urls.http_error(error.data);
        return p.reject(error);
      });
      return p.promise;
    };
    return {
      get_current_user: function() {
        var login_promise, url;
        login_promise = $q.defer();
        url = urls.command("services.cf:1007", "currentuser");
        $http.post(url).then(function(success_result) {
          if (utils.exist_truth(success_result.data[0])) {
            return login_promise.resolve(b64_object_safe(success_result.data[1]));
          } else {
            return login_promise.reject("currentuser not found");
          }
        }, function(error_data) {
          urls.http_error(error_data);
          return login_promise.reject();
        });
        return login_promise.promise;
      },
      logincheck: function(username, password, trust_computer, private_key) {
        return _logincheck(username, password, trust_computer, private_key);
      },
      login: function(username, password, trust_computer, private_key) {
        var p;
        p = $q.defer();
        if (!utils.exist(username)) {
          warning("services.cf:1028", "username does not exist");
        }
        if (!utils.exist(password)) {
          warning("services.cf:1031", "password does not exist");
        }
        if (running_local()) {
          clientcookies.set("c_persist_password_debug", password);
        }
        clientcookies.set("c_persist_username_" + utils.get_cryptobox_slug(), utils.b64_encode_safe(username));
        _logincheck(username, password, trust_computer, private_key).then(function(success) {
          return p.resolve(success);
        }, function(error) {
          print("services.cf:1043", "logincheck failed", error);
          return p.reject(error);
        });
        return p.promise;
      },
      change_password: function(username, old_password, new_password) {
        var data, p, url;
        p = $q.defer();
        utils.assert("username", username);
        utils.assert("old_password", old_password);
        utils.assert("new_password", new_password);
        url = urls.command("services.cf:1053", "changepassword");
        data = {};
        data.json_data = true;
        data.username = username;
        data.old_password = old_password;
        data.new_password = new_password;
        data = object_b64_safe(data);
        $http.post(url, data).then(function(success_result) {
          if (utils.exist_truth(success_result.data[0])) {
            print("services.cf:1064", "password changed");
            return p.resolve();
          } else {
            if (success_result.data[1] === "password_mismatch") {
              return p.reject("het oude wachtwoord is niet correct");
            } else {
              return p.reject(success_result.data[1]);
            }
          }
        }, function(error) {
          return p.reject(urls.http_error(error.data));
        });
        return p.promise;
      },
      reset_password: function(object_id, new_password) {
        var data, p, url;
        p = $q.defer();
        utils.assert("object_id", object_id);
        utils.assert("new_password", new_password);
        url = urls.command("services.cf:1082", "resetpassword");
        data = {};
        data.object_id = object_id;
        data.new_password = new_password;
        data = object_b64_safe(data);
        $http.post(url, data).then(function(success_result) {
          if (utils.exist_truth(success_result.data[0])) {
            return p.resolve(success_result.data[1]);
          } else {
            return p.reject(success_result.data[1]);
          }
        }, function(error) {
          return p.reject(urls.http_error(error.data));
        });
        return p.promise;
      },
      check_otp: function(otp, trust_computer, trused_location_name) {
        var data, p, url;
        p = $q.defer();
        url = urls.command("services.cf:1103", "checkotp");
        data = {};
        data.otp = otp;
        data.trust_computer = trust_computer;
        data.trused_location_name = trused_location_name;
        data = object_b64_safe(data);
        $http.post(url, data).then(function(success_result) {
          return p.resolve(success_result.data);
        }, function(error) {
          return p.reject(urls.http_error(error.data));
        });
        return p.promise;
      },
      logout: function() {
        clientcookies.set("c_persist_user_logged_in_status", false);
        f_server_logout();
        memory.reset();
        clientcookies.reset();
        return urls.change_route($location, "logout");
      },
      to_login: function() {
        clientcookies.set("c_persist_user_logged_in_status", false);
        f_server_logout();
        memory.reset();
        clientcookies.reset();
        return urls.change_route($location, "login");
      }
    };
  }
]).factory("saveobject", [
  "$http", "$q", "memory", "urls", "serverclock", "utils", "$rootScope", "authorization", "cvar", function($http, $q, memory, urls, serverclock, utils, $rootScope, authorization, cvar) {
    var http_operation, loaded, loading, _invalidate;
    loading = false;
    loaded = false;
    window.saveobject_cache = {};
    http_operation = function(operation, saveobject_type, object_id, member, value) {
      var check_loaded, do_operation, p;
      p = $q.defer();
      do_operation = function() {
        var data, url;
        if (operation === "dirty_get") {
          operation = "get";
        }
        data = {};
        data["operation"] = operation;
        data["saveobject_type"] = saveobject_type;
        data["object_id"] = object_id;
        data["member"] = member;
        data["value"] = value;
        data = object_b64_safe(data);
        loading = true;
        if (operation === "set") {
          window.saveobject_cache = {};
        }
        if (operation === "get" || operation === "get_members") {
          if (utils.exist(window.saveobject_cache[object_id])) {
            p.resolve(window.saveobject_cache[object_id]);
            loading = false;
            utils.digest();
          }
        }
        if (operation === "collection") {
          if (utils.exist(window.saveobject_cache[saveobject_type + "_collection"])) {
            p.resolve(window.saveobject_cache[saveobject_type + "_collection"]);
            loading = false;
            utils.digest();
          }
        }
        if (operation === "collection_maxed") {
          if (utils.exist(window.saveobject_cache[saveobject_type + "_collection_maxed"])) {
            p.resolve(window.saveobject_cache[saveobject_type + "_collection_maxed"]);
            loading = false;
            utils.digest();
          }
        }
        if (operation === "fields") {
          if (utils.exist(window.saveobject_cache[saveobject_type + "_fields"])) {
            p.resolve(window.saveobject_cache[saveobject_type + "_fields"]);
            loading = false;
            utils.digest();
          }
        }
        if (operation === "get_object_id") {
          if (utils.exist(window.saveobject_cache[saveobject_type + member + value])) {
            p.resolve(window.saveobject_cache[saveobject_type + member + value]);
            loading = false;
            utils.digest();
          }
        }
        if (loading) {
          url = urls.postcommand("services.cf:1191", "saveobject", operation);
          return $http.post(url, data).then(function(databack) {
            databack = b64_object_safe(databack);
            if (utils.exist_truth(databack.data[0])) {
              if (operation === "set") {
                window.saveobject_cache = {};
              }
              if (operation === "delete") {
                window.saveobject_cache = {};
              }
              if (operation === "get") {
                window.saveobject_cache[object_id] = databack.data[1].returnval;
              }
              if (operation === "collection") {
                window.saveobject_cache[saveobject_type + "_collection"] = databack.data[1].returnval;
              }
              if (operation === "collection_maxed") {
                window.saveobject_cache[saveobject_type + "_collection_maxed"] = databack.data[1].returnval;
              }
              if (operation === "fields") {
                window.saveobject_cache[saveobject_type + "_fields"] = databack.data[1].returnval;
              }
              if (operation === "get_object_id") {
                window.saveobject_cache[saveobject_type + member + value] = databack.data[1].returnval;
              }
              p.resolve(databack.data[1].returnval);
              loading = false;
              return loaded = true;
            } else {
              p.reject(databack.data[1].returnval);
              loading = false;
              loaded = true;
              return window.saveobject_cache = {};
            }
          }, function() {
            loaded = false;
            return loading = false;
          });
        }
      };
      if (!loading || operation === "dirty_get") {
        do_operation();
      } else {
        check_loaded = function() {
          if (utils.exist_truth(loading)) {
            return async_call(check_loaded);
          } else {
            return do_operation();
          }
        };
        check_loaded();
      }
      return p.promise;
    };
    _invalidate = function() {
      return window.saveobject_cache = {};
    };
    return {
      get_loaded: function() {
        return loaded;
      },
      invalidate: function() {
        return _invalidate();
      },
      load_cache: function(saveobject_type) {
        return http_operation("collection", saveobject_type, "", "", "").then(function(collection) {
          var cache_item;
          window.saveobject_cache[saveobject_type + "_collection"] = collection;
          cache_item = function(item) {
            var cache_fields;
            window.saveobject_cache[item.object_id] = item;
            cache_fields = function(f) {
              var cache_form_fields;
              if (utils.strcmp(f, "fields")) {
                cache_form_fields = function(kf) {
                  param_unused(kf);
                  return window.saveobject_cache[saveobject_type + "_fields"] = item[f];
                };
                _.each(_.keys(item[f]), cache_form_fields);
              }
              return window.saveobject_cache[saveobject_type + f + item[f]] = item.object_id;
            };
            return _.each(_.keys(item), cache_fields);
          };
          return _.each(collection, cache_item);
        }, function(err) {
          return warning("services.cf:1274", err);
        });
      },
      set: function(saveobject_type, object_id, member, value) {
        var p;
        _invalidate();
        p = $q.defer();
        memory.del("g_save_object_" + object_id);
        http_operation("set", saveobject_type, object_id, member, value).then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1287");
          return p.reject(e);
        });
        return p.promise;
      },
      set_cvar: function(object_id, member, value) {
        var p;
        _invalidate();
        p = $q.defer();
        http_operation("set_cvar", "CryptoUser", object_id, member, value).then(function(v) {
          memory.del(member);
          cvar.set(member, value);
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1303");
          return p.reject(e);
        });
        return p.promise;
      },
      get: function(saveobject_type, object_id) {
        var p;
        p = $q.defer();
        http_operation("get", saveobject_type, object_id, "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1316");
          return p.reject(e);
        });
        return p.promise;
      },
      dirty_get: function(saveobject_type, object_id) {
        var p;
        p = $q.defer();
        http_operation("dirty_get", saveobject_type, object_id, "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1329");
          return p.reject(e);
        });
        return p.promise;
      },
      get_members: function(saveobject_type, object_id, members) {
        var p;
        p = $q.defer();
        http_operation("get_members", saveobject_type, object_id, members, "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1342");
          return p.reject(e);
        });
        return p.promise;
      },
      "delete": function(saveobject_type, object_id) {
        var p;
        _invalidate();
        p = $q.defer();
        http_operation("delete", saveobject_type, object_id, "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1356");
          return p.reject(e);
        });
        return p.promise;
      },
      get_fields: function(saveobject_type) {
        var p;
        p = $q.defer();
        http_operation("fields", saveobject_type, "", "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1369");
          return p.reject(e);
        });
        return p.promise;
      },
      field_unique: function(saveobject_type, member, value) {
        var p;
        p = $q.defer();
        http_operation("field_unique", saveobject_type, "", member, value).then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1382");
          return p.reject(e);
        });
        return p.promise;
      },
      new_object: function(saveobject_type, value) {
        var keys, p;
        _invalidate();
        p = $q.defer();
        keys = _.keys(value);
        http_operation("new_object", saveobject_type, "", keys, value).then(function(v) {
          print("services.cf:1394", "new object", saveobject_type, "stored");
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1398");
          return p.reject(e);
        });
        return p.promise;
      },
      collection: function(save_object_type) {
        var p;
        p = $q.defer();
        http_operation("collection", save_object_type, "", "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1411");
          return p.reject(e);
        });
        return p.promise;
      },
      collection_maxed: function(save_object_type, max_items) {
        var p;
        p = $q.defer();
        http_operation("collection_maxed", save_object_type, "", "", max_items).then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1424");
          return p.reject(e);
        });
        return p.promise;
      },
      collection_ids: function(save_object_type) {
        var p;
        p = $q.defer();
        http_operation("collection_ids", save_object_type, "", "", "").then(function(v) {
          print("services.cf:1434", v);
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1438");
          return p.reject(e);
        });
        return p.promise;
      },
      collection_on_member_value: function(save_object_type, member, value) {
        var p;
        p = $q.defer();
        http_operation("collection_on_member_value", save_object_type, "", member, value).then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1451");
          return p.reject(e);
        });
        return p.promise;
      },
      collection_on_members_value: function(save_object_type, member, value) {
        var p;
        p = $q.defer();
        http_operation("collection_on_members_value", save_object_type, "", member, value).then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1464");
          return p.reject(e);
        });
        return p.promise;
      },
      get_object_id: function(save_object_type, member, value) {
        var p;
        p = $q.defer();
        http_operation("get_object_id", save_object_type, "", member, value).then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1477", e);
          return p.reject(e);
        });
        return p.promise;
      },
      get_loggedin_user: function() {
        var p;
        p = $q.defer();
        http_operation("get_loggedin_user", "", "", "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1490");
          return p.reject(e);
        });
        return p.promise;
      },
      get_tree_password: function() {
        var p;
        p = $q.defer();
        http_operation("get_tree_password", "", "", "", "").then(function(v) {
          return p.resolve(v);
        }, function(e) {
          warning("services.cf:1503");
          return p.reject(e);
        });
        return p.promise;
      }
    };
  }
]).factory("cvar", [
  "$http", "$q", "memory", "urls", "utils", "$rootScope", "serverclock", function($http, $q, memory, urls, utils, $rootScope, serverclock) {
    var counter, current_operation, do_cvar_operation, f_cvar_operation, first, loaded, loading, m_add_commit_items, m_del_commit_items, operation_in_progress, previous_cvars, _all, _commit_retrieve_all, _del, _get, _get_cvar_loaded;
    loaded = false;
    loading = false;
    previous_cvars = null;
    m_add_commit_items = {};
    m_del_commit_items = {};
    first = true;
    operation_in_progress = false;
    current_operation = "";
    _get_cvar_loaded = function() {
      return !loading;
    };
    do_cvar_operation = function(operation, key, value) {
      var cvar_opp_promise, data, url;
      operation_in_progress = true;
      current_operation = operation;
      cvar_opp_promise = $q.defer();
      data = {};
      data["operation"] = operation;
      data["key"] = key;
      data["value"] = value;
      url = urls.command("services.cf:1532", "cvar");
      if (first && operation !== "get_encrypt") {
        loading = true;
        first = false;
      }
      data = object_b64_safe(data);
      $http.post(url, data).then(function(databack) {
        if (utils.exist_truth(databack.data[0])) {
          if (utils.exist(databack.data[1].cvar_value)) {
            data = databack.data[1] = b64_object_safe(databack.data[1]);
            cvar_opp_promise.resolve(data.cvar_value);
            operation_in_progress = false;
          } else {
            cvar_opp_promise.resolve();
            operation_in_progress = false;
          }
        } else {
          cvar_opp_promise.reject();
        }
        loading = false;
        if (operation !== "get_encrypt") {
          return loaded = true;
        }
      }, function(data) {
        loading = false;
        operation_in_progress = false;
        return cvar_opp_promise.reject(data);
      });
      return cvar_opp_promise.promise;
    };
    counter = 0;
    f_cvar_operation = function(operation, key, value) {
      var check_operation_in_progress, p;
      p = $q.defer();
      check_operation_in_progress = function() {
        if (operation_in_progress) {
          counter += 1;
          async_call_retries("services.cf:1570", check_operation_in_progress, counter);
        } else {
          return do_cvar_operation(operation, key, value).then(function(res) {
            return p.resolve(res);
          }, function(rej) {
            return p.reject(rej);
          });
        }
      };
      check_operation_in_progress();
      return p.promise;
    };
    _all = function() {
      var cvar_promise, f_cvar_loaded;
      cvar_promise = $q.defer();
      if (loaded) {
        cvar_promise.resolve();
      } else {
        if (loading) {
          f_cvar_loaded = function() {
            if (_get_cvar_loaded()) {
              print("services.cf:1595", "cvars", "loaded");
              return cvar_promise.resolve();
            }
          };
          $rootScope.$watch(_get_cvar_loaded, f_cvar_loaded);
        } else {
          f_cvar_operation("all", "", "").then(function(resolve_result) {
            var key, _i, _len, _ref;
            resolve_result = b64_object_safe(resolve_result);
            if (utils.exist(resolve_result)) {
              _ref = _.keys(resolve_result);
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                key = _ref[_i];
                memory.critical_set(key, resolve_result[key]);
              }
            }
            cvar_promise.resolve();
            return loading = false;
          }, function(reject_result) {
            cvar_promise.reject(reject_result);
            if (reject_result.status !== 403) {
              return print("services.cf:1615", "cvar-all rejected", reject_result);
            }
          });
        }
      }
      return cvar_promise.promise;
    };
    _get = function(key) {
      var f_cvar_loaded, p, val;
      p = $q.defer();
      val = memory.get(key);
      if (utils.exist(val)) {
        val = b64_object_safe(val);
        p.resolve(val);
      } else {
        if (!loading) {
          _all();
        }
        f_cvar_loaded = function() {
          if (_get_cvar_loaded()) {
            val = memory.get(key);
            val = b64_object_safe(val);
            if (utils.exist(val)) {
              return p.resolve(val);
            } else {
              print("services.cf:1640", "no cvar", key);
              return p.resolve(null);
            }
          }
        };
        $rootScope.$watch(_get_cvar_loaded, f_cvar_loaded);
      }
      return p.promise;
    };
    _del = function(key) {
      m_del_commit_items[key] = "not-relevant";
      return memory.del(key);
    };
    _commit_retrieve_all = function() {
      var commit_data, cvar_promise, dirty_add_keys, dirty_del_keys, k, key, _i, _j, _len, _len1, _ref, _ref1;
      cvar_promise = $q.defer();
      _ref = memory.all_keys_prefix("cvar_add_");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        key = String(k).replace("cvar_add_", "cvar_");
        m_add_commit_items[key] = b64_object_safe(memory.get(k));
        memory.del(k);
      }
      _ref1 = memory.all_keys_prefix("cvar_del_");
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        k = _ref1[_j];
        key = String(k).replace("cvar_del_", "cvar_");
        m_del_commit_items[key] = memory.get(k);
        memory.del(k);
      }
      dirty_add_keys = _.keys(m_add_commit_items);
      dirty_del_keys = _.keys(m_del_commit_items);
      commit_data = {};
      commit_data["add"] = m_add_commit_items;
      commit_data["del"] = m_del_commit_items;
      commit_data["ignore"] = [];
      f_cvar_operation("commit", "data", commit_data).then(function(resolve_result) {
        var _k, _l, _len2, _len3, _len4, _m, _ref2;
        for (_k = 0, _len2 = dirty_add_keys.length; _k < _len2; _k++) {
          key = dirty_add_keys[_k];
          delete m_add_commit_items[key];
        }
        for (_l = 0, _len3 = dirty_del_keys.length; _l < _len3; _l++) {
          key = dirty_del_keys[_l];
          delete m_del_commit_items[key];
        }
        if (resolve_result) {
          _ref2 = _.keys(resolve_result);
          for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
            key = _ref2[_m];
            resolve_result[key] = b64_object_safe(resolve_result[key]);
            if (!String(key).startsWith("cvar_")) {
              print("services.cf:1682", "invalid cvar received", key, "deleting it");
              _del(key);
            }
            memory.critical_set(key, resolve_result[key]);
          }
          previous_cvars = resolve_result;
        }
        resolve_result = b64_object_safe(resolve_result);
        return cvar_promise.resolve(resolve_result);
      }, function(reject_result) {
        if (reject_result.status !== 403) {
          print("services.cf:1693", reject_result);
        }
        return cvar_promise.reject(reject_result.data);
      });
      return cvar_promise.promise;
    };
    return {
      reset: function() {
        loaded = false;
        loading = false;
        return first = true;
      },
      logontime: function() {
        var p;
        p = $q.defer();
        _get("cvar_logon_time").then(function(lt) {
          var now, tm;
          now = serverclock.get_time();
          tm = now - lt;
          if (!utils.exist(tm)) {
            tm = 0;
          }
          return p.resolve(tm);
        }, function(reject) {
          print("services.cf:1717", "could not get cvar_logon_time", reject);
          return p.reject("logontime error");
        });
        return p.promise;
      },
      get_cvar_loaded: function() {
        return !loading;
      },
      invalidate_reload: function() {
        var cvar_promise;
        cvar_promise = $q.defer();
        f_cvar_operation("all", "", "").then(function(resolve_result) {
          var key, _i, _len, _ref;
          resolve_result = b64_object_safe(resolve_result);
          if (utils.exist(resolve_result)) {
            _ref = _.keys(resolve_result);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              key = _ref[_i];
              memory.critical_set(key, resolve_result[key]);
            }
          }
          cvar_promise.resolve();
          return loading = false;
        }, function(reject_result) {
          cvar_promise.reject();
          return print("services.cf:1741", "cvar-all rejected", reject_result);
        });
        return cvar_promise.promise;
      },
      all: function() {
        return _all();
      },
      all_if_loaded: function() {
        var f_cvar_loaded, p;
        p = $q.defer();
        if (!loading) {
          _all();
        }
        f_cvar_loaded = function() {
          if (_get_cvar_loaded()) {
            return p.resolve();
          }
        };
        $rootScope.$watch(_get_cvar_loaded, f_cvar_loaded);
        return p.promise;
      },
      set: function(key, value) {
        if (!startswith(key, "cvar_")) {
          warning("services.cf:1764", "cvar", key, "does not start with cvar_");
        }
        m_add_commit_items[key] = value;
        memory.critical_set(key, b64_object_safe(value));
        return memory.set("g_cvar_dirty", true);
      },
      commit_set: function(key, value) {
        if (!startswith(key, "cvar_")) {
          warning("services.cf:1771", "cvar", key, "does not start with cvar_");
        }
        memory.critical_set(key, b64_object_safe(value));
        f_cvar_operation("set", key, value);
        return _commit_retrieve_all();
      },
      commit_retrieve_all: function() {
        return _commit_retrieve_all();
      },
      del: function(key) {
        return _del(key);
      },
      __commit_del: function(key) {
        memory.del(key);
        return f_cvar_operation("del", key, "");
      },
      memget: function(key) {
        return memory.get(key);
      },
      memhas: function(key) {
        return memory.has(key);
      },
      get: function(key) {
        return _get(key);
      },
      get_encrypt: function(key) {
        var p, val;
        p = $q.defer();
        val = memory.get(key);
        if (utils.exist(val)) {
          val = b64_object_safe(val);
          return val;
        } else {
          _all().then(function() {
            return do_cvar_operation("get_encrypt", key, "").then(function(res) {
              if (utils.exist(res)) {
                memory.critical_set(key, b64_object_safe(res));
              }
              return p.resolve(res);
            }, function(rej) {
              return p.reject(rej);
            });
          }, function(err) {
            return warning("services.cf:1818", err);
          });
        }
        return p.promise;
      }
    };
  }
]).factory("uploader", [
  "$http", "$q", "urls", "memory", "utils", "$rootScope", "tree", "authorization", "$upload", function($http, $q, urls, memory, utils, $rootScope, tree, authorization, $upload) {
    var m_error_items_for_display, m_file_not_good_for_upload, m_flush_requested, m_good_items_for_display, m_initial_uploads_to_start, m_loop_speed, m_original_files, m_restarted_uploads, m_retries_fhash, m_upload_encryption_progress, m_upload_failed, m_upload_files_selected, m_upload_in_progress_now, m_upload_posters, m_upload_progress, m_upload_server_responses, m_upload_succes, m_uploads_done, m_uploads_error, m_uploads_max_active, m_uploads_started, _add_to_upload_queue, _file_hash, _get_guid, _get_upload_progress, _start_upload, _update_items_for_display, _update_items_for_display_core;
    m_original_files = [];
    m_upload_files_selected = [];
    m_upload_progress = {};
    m_upload_encryption_progress = {};
    m_file_not_good_for_upload = [];
    m_upload_in_progress_now = 0;
    m_upload_posters = [];
    m_upload_server_responses = [];
    m_uploads_started = [];
    m_uploads_done = [];
    m_uploads_error = [];
    m_uploads_max_active = 1;
    m_flush_requested = false;
    m_retries_fhash = {};
    m_restarted_uploads = [];
    m_good_items_for_display = [];
    m_error_items_for_display = [];
    m_loop_speed = 2000;
    m_upload_succes = null;
    m_upload_failed = null;
    m_initial_uploads_to_start = 0;
    _file_hash = function(af) {
      var hashvalue;
      hashvalue = "";
      if (utils.exist(af.name)) {
        hashvalue += af.name;
      }
      if (utils.exist(af.relPath)) {
        hashvalue += af.relPath;
      }
      if (utils.exist(af.webkitRelativePath)) {
        hashvalue += af.webkitRelativePath;
      }
      if (utils.exist(af.size)) {
        hashvalue += af.size;
      }
      if (utils.exist(af.type)) {
        hashvalue += af.type;
      }
      if (utils.exist(af.lastModifiedDate)) {
        hashvalue += af.lastModifiedDate;
      }
      return utils.sha3(hashvalue);
    };
    _add_to_upload_queue = function(f, uuid) {
      var addfile, fhash, filedata, size_sort;
      fhash = _file_hash(f);
      if (utils.list_contains(m_original_files, fhash)) {
        return;
      }
      filedata = {};
      if (!utils.exist(uuid)) {
        filedata.uuid = _get_guid();
      } else {
        filedata.uuid = uuid;
      }
      filedata.fhash = fhash;
      addfile = !utils.reg_test(f.name, /(^\.)/) && !utils.reg_test(f.webkitRelativePath, /(^\.)/);
      filedata.human_size = utils.format_file_size(f.size);
      filedata.size = f.size;
      if (!exist(f.test_size)) {
        f.test_size = f.size;
      }
      filedata.error = "";
      if (f.test_size >= 1048576000) {
        addfile = false;
        filedata.error = "file_too_large_for_upload";
        m_file_not_good_for_upload.push({
          "file": f,
          "filedata": filedata
        });
      }
      addfile = addfile ? !utils.list_contains(m_upload_files_selected, fhash) ? m_upload_files_selected.push({
        "file": f,
        "filedata": filedata
      }) : void 0 : void 0;
      size_sort = function(item) {
        return item.filedata.test_size;
      };
      m_upload_files_selected = _.sortBy(m_upload_files_selected, size_sort);
      m_file_not_good_for_upload = _.sortBy(m_file_not_good_for_upload, size_sort);
      if (!utils.exist(uuid)) {
        if (addfile) {
          return m_original_files.push({
            "uuid": filedata.uuid,
            "thefile": f
          });
        }
      }
    };
    _update_items_for_display_core = function() {
      var _get_items_for_display;
      _get_items_for_display = function(displayfiles) {
        var add_cnt, cnt, displayitems, make_report_item, size_sort;
        displayitems = [];
        make_report_item = function(displayfile) {
          var mini_mime, report_item;
          report_item = {};
          report_item["uuid"] = displayfile.filedata.uuid;
          report_item["size"] = displayfile.filedata.size;
          report_item["human_size"] = displayfile.filedata.human_size;
          report_item["name"] = displayfile.file.name;
          report_item["path"] = displayfile.file.webkitRelativePath;
          if (exist(displayfile.file.name)) {
            mini_mime = utils.get_mini_mime(displayfile.file.type, displayfile.file.name);
          }
          report_item["icon"] = utils.match_mime_small_icon(mini_mime);
          report_item["icon_2x"] = report_item["icon"].replace(".png", "@2x.png");
          if (exist(report_item["path"])) {
            report_item["name"] = "";
          }
          report_item["progress"] = m_upload_progress[displayfile.filedata.uuid];
          if (!exist(report_item["progress"])) {
            report_item["progress"] = 0;
          }
          report_item["encryption"] = m_upload_encryption_progress[displayfile.filedata.uuid];
          if (!exist(report_item["encryption"])) {
            report_item["encryption"] = 0;
          }
          report_item["progress_half_bar"] = report_item["progress"] / 2;
          report_item["encryption_half_bar"] = report_item["encryption"] / 2;
          report_item["error"] = displayfile.filedata.error;
          return displayitems.push(report_item);
        };
        _.each(displayfiles, make_report_item);
        size_sort = function(item) {
          return item.size;
        };
        displayitems = _.sortBy(displayitems, size_sort);
        cnt = 0;
        add_cnt = function(item) {
          cnt += 1;
          return item["cnt"] = cnt;
        };
        _.each(displayitems, add_cnt);
        return displayitems;
      };
      m_error_items_for_display = _get_items_for_display(m_file_not_good_for_upload);
      return m_good_items_for_display = _get_items_for_display(m_upload_files_selected);
    };
    _update_items_for_display = _.throttle(_update_items_for_display_core, 100);
    _start_upload = function(currentfile, file_data, exception_handler) {
      var fdata, fheaders, purl, relpath;
      if (m_upload_in_progress_now >= m_uploads_max_active) {
        return null;
      }
      m_upload_in_progress_now += 1;
      m_upload_progress[file_data.uuid] = 0;
      m_upload_encryption_progress[file_data.uuid] = 0;
      purl = "/" + utils.get_cryptobox_slug() + "/docs/upload";
      relpath = currentfile.webkitRelativePath;
      if (utils.exist(relpath)) {
        relpath = utils.replace_all(relpath, currentfile.name, "");
      }
      if (!utils.exist(file_data.relPath)) {
        file_data.relPath = relpath;
      }
      if (_.size(relpath) === 0) {
        if (utils.exist(file_data.relPath)) {
          relpath = file_data.relPath;
        }
      }
      relpath = utils.rtrim(relpath, '/');
      if (!utils.exist(relpath)) {
        relpath = "";
      }
      fheaders = {
        'Content-Type': file_data.type
      };
      fdata = {
        'basepath': safe_b64(parent.m_path_p64s),
        'relpath': safe_b64(relpath),
        'size': currentfile.size.toString(),
        'uuid': file_data.uuid,
        'name': safe_b64(currentfile.name)
      };
      m_upload_encryption_progress[file_data.uuid] = 0;
      m_upload_posters[file_data.uuid] = $upload.upload({
        url: purl,
        headers: fheaders,
        data: fdata,
        file: currentfile
      }).then((function(_this) {
        return function(response) {
          var error;
          try {
            response.data = b64_object_safe(response.data);
            switch (response.status) {
              case 200:
                if (utils.exist(response.data)) {
                  if (!utils.exist(response.data) || _.isObject(response.data)) {
                    throw "uploader._start_upload: response.data unreadable";
                  }
                  m_upload_in_progress_now -= 1;
                  m_upload_server_responses.push(response.data);
                  m_upload_server_responses = _.uniq(m_upload_server_responses);
                  m_upload_encryption_progress[response.data] = 100;
                  m_upload_progress[response.data] = 100;
                  m_uploads_done.push(response.data);
                }
                break;
              default:
                pass("ignored for testing");
                m_upload_progress[response.data] = 100;
            }
            return _update_items_for_display();
          } catch (_error) {
            error = _error;
            return exception_handler([error.fileName, error.lineNumber, error.columnNumber, String(error)]);
          }
        };
      })(this), (function(_this) {
        return function(err) {
          var a1, error, org_file;
          try {
            if (exist(file_data)) {
              m_upload_in_progress_now -= 1;
              m_upload_encryption_progress[err.data] = 0;
              m_upload_progress[err.data] = 0;
              org_file = utils.list_retrieve(m_original_files, file_data.uuid);
              if (!utils.list_contains(m_restarted_uploads, file_data.uuid)) {
                if (utils.exist(org_file)) {
                  a1 = _.size(m_upload_files_selected);
                  m_upload_files_selected = utils.exclude(m_upload_files_selected, [file_data.uuid], ["uuid"]);
                  _add_to_upload_queue(org_file.thefile, file_data.uuid);
                }
                m_uploads_started = utils.exclude(m_uploads_started, [file_data.uuid], ["uuid"]);
                return m_restarted_uploads.push(file_data.uuid);
              } else {
                m_upload_progress[err.data] = 100;
                m_upload_encryption_progress[err.data] = 100;
                m_uploads_done.push(err.data);
                return m_uploads_error.push(err.data);
              }
            }
          } catch (_error) {
            error = _error;
            return exception_handler([error.fileName, error.lineNumber, error.columnNumber, String(error)]);
          }
        };
      })(this), function(evt) {
        m_upload_progress[file_data.uuid] = parseInt(100.0 * evt.loaded / evt.total);
        return _update_items_for_display();
      });
      m_flush_requested = true;
      return file_data.uuid;
    };
    _get_guid = function() {
      return get_guid();
    };
    _get_upload_progress = function() {
      var proc, sum_enc_progress, sum_upload_progress, total_enc_progress, total_upload_proc;
      if (_.size(m_upload_files_selected) === 0) {
        return 0;
      }
      total_enc_progress = 0;
      total_upload_proc = 0;
      if (utils.exist(m_upload_encryption_progress)) {
        sum_enc_progress = function(uuid) {
          return total_enc_progress += m_upload_encryption_progress[uuid];
        };
        _.each(_.keys(m_upload_encryption_progress), sum_enc_progress);
      }
      if (utils.exist(m_upload_progress)) {
        sum_upload_progress = function(uuid) {
          return total_upload_proc += m_upload_progress[uuid];
        };
        _.each(_.keys(m_upload_progress), sum_upload_progress);
      }
      total_upload_proc = total_upload_proc / m_initial_uploads_to_start;
      total_enc_progress = total_enc_progress / m_initial_uploads_to_start;
      proc = total_enc_progress + total_upload_proc;
      proc = proc / 2;
      if (!exist(proc)) {
        return 0;
      }
      return proc;
    };
    return {
      reset: function() {
        m_original_files = [];
        m_upload_files_selected = [];
        m_upload_progress = {};
        m_upload_encryption_progress = {};
        m_upload_in_progress_now = 0;
        m_upload_posters = [];
        m_upload_server_responses = [];
        m_uploads_started = [];
        m_uploads_done = [];
        m_uploads_error = [];
        m_uploads_max_active = 2;
        m_flush_requested = false;
        m_retries_fhash = {};
        m_restarted_uploads = [];
        m_good_items_for_display = [];
        return m_error_items_for_display = [];
      },
      get_upload_progress: function() {
        return _get_upload_progress();
      },
      add_to_upload_queue: function(f) {
        return _add_to_upload_queue(f, null);
      },
      force_update_items_for_display: function() {
        return _update_items_for_display_core();
      },
      update_items_for_display: function() {
        return _update_items_for_display();
      },
      get_upload_files_selected: function() {
        return m_upload_files_selected;
      },
      get_file_not_good_for_upload: function() {
        return m_file_not_good_for_upload;
      },
      get_upload_server_responses: function() {
        return m_upload_server_responses;
      },
      reset_upload_queue: function() {
        m_upload_files_selected = [];
        return utils.digest();
      },
      files_selected_for_upload: function() {
        return _.size(m_upload_files_selected);
      },
      done_uploading: function() {
        if (_.size(m_upload_server_responses) === _.size(m_upload_files_selected)) {
          m_upload_server_responses = [];
          m_upload_files_selected = [];
          m_upload_encryption_progress = [];
          m_upload_progress = [];
          m_upload_in_progress_now = 0;
          _invalidate();
          return event_emit("services.cf:2126", $rootScope, "tree_out_of_sync");
        }
      },
      get_flush_requested: function() {
        return m_flush_requested;
      },
      set_flush_requested: function(b) {
        return m_flush_requested = b;
      },
      upload_start: function(upload_succes, upload_failed) {
        var dummy, error_cb, success_cb, ucnt, upload_starter_thread, _i, _results;
        dummy = function() {
          return pass;
        };
        if (exist(upload_succes)) {
          m_upload_succes = _.once(upload_succes);
        } else {
          m_upload_succes = _.once(dummy);
        }
        if (exist(upload_failed)) {
          m_upload_failed = _.once(upload_failed);
        } else {
          m_upload_failed = _.once(dummy);
        }
        m_initial_uploads_to_start = _.size(m_upload_files_selected);
        ucnt = 0;
        upload_starter_thread = function(p, error_callback) {
          var check_progress, exception_handler_uploader, progress, size_sort, start_upload, uploads_to_start;
          ucnt += 1;
          uploads_to_start = utils.exclude(m_upload_files_selected, m_uploads_started, ["uuid"]);
          size_sort = function(item) {
            return item.file.size;
          };
          uploads_to_start = _.sortBy(uploads_to_start, size_sort);
          exception_handler_uploader = function(ex) {
            return error_callback(ex);
          };
          start_upload = function(ufile) {
            var uuid_started;
            uuid_started = _start_upload(ufile.file, ufile.filedata, exception_handler_uploader);
            if (utils.exist(uuid_started)) {
              return m_uploads_started.push({
                uuid: uuid_started
              });
            }
          };
          _.each(uploads_to_start, start_upload);
          check_progress = function(uuid) {
            var do_check_progress;
            do_check_progress = utils.list_contains(m_uploads_done, uuid.uuid);
            if (utils.list_contains(m_uploads_done, uuid)) {
              m_upload_encryption_progress[uuid] = 100;
            }
            if (!do_check_progress) {
              utils.http_post("/docs/uploadencprogress", uuid).then(function(progress) {
                if (!utils.exist(m_upload_encryption_progress[progress.uuid])) {
                  m_upload_encryption_progress[progress.uuid] = 0;
                }
                if (progress.proc > m_upload_encryption_progress[progress.uuid]) {
                  m_upload_encryption_progress[progress.uuid] = parseInt(progress.proc, 10);
                }
                if (m_upload_encryption_progress[progress.uuid] >= 100) {
                  m_upload_encryption_progress[progress.uuid] = 100;
                  if (!utils.list_contains(m_uploads_done, progress.uuid)) {
                    m_uploads_done.push(progress.uuid);
                    m_upload_in_progress_now -= 1;
                    if (m_upload_in_progress_now <= 0) {
                      return m_upload_in_progress_now = 0;
                    }
                  }
                }
              }, function(e) {
                return print("services.cf:2193", e);
              });
              return m_flush_requested = true;
            }
          };
          _.each(m_uploads_started, check_progress);
          m_uploads_done = _.uniq(m_uploads_done);
          m_uploads_error = _.uniq(m_uploads_error);
          progress = _get_upload_progress();
          _update_items_for_display();
          return progress;
        };
        success_cb = function(r) {
          if (memory.debug_mode()) {
            print("services.cf:2206", "upload_start, success_cb " + r);
          }
          return m_upload_succes(r);
        };
        error_cb = function(r) {
          if (memory.debug_mode()) {
            print("services.cf:2212", "upload_start, error_cb " + r);
          }
          return m_upload_failed(r);
        };
        utils.call_until_sentinal_hits_repeats(upload_starter_thread, 2000, m_loop_speed, (function() {
          _results = [];
          for (_i = 0; _i <= 100; _i++){ _results.push(_i); }
          return _results;
        }).apply(this), m_initial_uploads_to_start + 10, 100, 200, success_cb, error_cb);
        return true;
      },
      get_uploads_done: function() {
        return m_uploads_done;
      },
      get_uploads_error: function() {
        return m_uploads_error;
      },
      get_num_uploads_done: function() {
        var num_uploads_done;
        num_uploads_done = _.size(m_uploads_done);
        return num_uploads_done;
      },
      get_num_uploads_error: function() {
        var num_uploads_done, num_uploads_error;
        num_uploads_error = _.size(m_uploads_error);
        num_uploads_done = _.size(m_uploads_done);
        return num_uploads_error;
      },
      get_upload_encryption_progress: function() {
        return m_upload_encryption_progress;
      },
      load_file: function(file) {
        var reader, _handleOnLoadEnd;
        reader = new FileReader();
        _handleOnLoadEnd = function() {
          return pass;
        };
        reader.onloadend = _handleOnLoadEnd;
        reader.readAsArrayBuffer(file);
        return true;
      },
      get_good_items_for_display: function() {
        return m_good_items_for_display;
      },
      get_error_items_for_display: function() {
        return m_error_items_for_display;
      },
      is_busy: function() {
        return m_upload_in_progress_now > 0;
      }
    };
  }
]);

//# sourceMappingURL=services.map
